" basic vim settings {{{

" enable syntax
if !exists("g:syntax_on")
  syntax enable
endif

" colorscheme
colorscheme default

" update leader
let mapleader = ","
" map local leader- can use for other commands with <localleader>
let maplocalleader = "\\"

" omnicomplete
set omnifunc=syntaxcomplete#Complete

"wrapped lines go down/up to next row
noremap j gj
noremap k gk

" retain buffers until quit
set hidden

" do not use modeline
" modeline is a security risk
set nomodeline

" No bells!
set visualbell

" Fast scrolling
set ttyfast

" allow recursive searching with :find
set path+=**

" not case sensitive, unless all caps
set ignorecase
set smartcase

" make backspace work
set backspace=2

" set lines above/below cursor
set so=0

" turn on wild menu
set wildmenu

"2nd tab: complete first alternative, allow tab/S-tab to cycle back and forth
set wildmode=longest:full,full
set foldcolumn=0

" path/file expansion in colon-mode
"set wildmode=longest:full,list:full,list:longest
"set wildchar=<TAB>

"Brace face
set showmatch
set matchtime=3

" split down and right
set splitbelow
set splitright

" filetype
filetype plugin on

" indentation
filetype indent on
set autoindent
set smartindent

" Time out on key codes but not mappings
set notimeout
set ttimeout
set ttimeoutlen=10

"set utf8 as standard encoding
set encoding=utf8

" use spaces instead of tabs
set expandtab

"be smart when using tabs!
set smarttab

" 1 tab == 4 spaces
set shiftwidth=4
set tabstop=4
set softtabstop=4
set wrap

" search shows all results
set incsearch
set showmatch
set hlsearch

" Line numbers
set nonumber

" create backup folders if not created
if !isdirectory($HOME."/.vim/backup")
  silent! execute "!mkdir ~/.vim/backup"
endif

if !isdirectory($HOME."/.vim/undo")
  silent! execute "~mkdir !/.vim/undo"
endif

set maxmempattern=20000 " increase max memory -- show syntax highlighting for large files
set history=1000
set undofile
set undodir=~/.vim/undo " where to save undo history
set undolevels=1000 " How many undos
set undoreload=10000 " number of lines to save for undo
set backupdir=~/.vim/backup
set viminfo='1000 " need for FzfHistory
set noswapfile

set nocompatible
set foldmethod=marker
set clipboard=unnamed "use system default clipboard

" Disable scrollbars
set guioptions-=r
set guioptions-=R
set guioptions-=l
set guioptions-=L

" no arrow keys
nnoremap <up> <nop>
nnoremap <down> <nop>
nnoremap <left> <nop>
nnoremap <right> <nop>

"}}}

" neovim settings {{{

if has('nvim')
  " neovim commands
  " neovim terminal - esc to exit terminal-mode
  :tnoremap <Esc> <C-\><C-n>

  " set termguicolors
  set termguicolors

  " do not show line numbers in terminal mode
  augroup termsettings
    autocmd!
    autocmd TermOpen * setlocal nonumber norelativenumber
  augroup END
endif

" }}}

" visuals {{{

" set default colors on vim and window enter
augroup colors
  autocmd VimEnter * hi Todo ctermfg=0 ctermbg=11 guifg=#8b0000 guibg=#ffff00
  autocmd VimEnter * hi folded guibg=Black ctermfg=8 guifg=White ctermbg=15
  autocmd VimEnter * hi statusline guibg=Black ctermfg=8 guifg=White ctermbg=15
  autocmd InsertEnter * call InsertStatuslineColor(v:insertmode)
  autocmd InsertLeave * hi statusline guibg=Black ctermfg=8 guifg=White ctermbg=15
augroup END

" set statusline color for various modes
function! InsertStatuslineColor(mode)
  if a:mode == 'i'
  hi statusline guibg=Orange ctermfg=6 guifg=Black ctermbg=0
  elseif a:mode == 'r'
  hi statusline guibg=Purple ctermfg=5 guifg=Black ctermbg=0
  else
  hi statusline guibg=DarkRed ctermfg=1 guifg=Black ctermbg=0
  endif
endfunction

set laststatus=2

function! StatusLineBuffNum()
  let bnum = expand(bufnr('%'))
  return printf("-%d-", bnum)
endfunction

function! StatusLineFiletype()
  return winwidth(0) > 160 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! StatusLineFormat()
  return winwidth(0) > 160 ? printf("%s | %s", &ff, &fenc) : ''
endfunction

function! StatusLineFileName()
  let fname = '' != expand('%:f') ? expand('%:f') : '[No Name]'
  return printf("%s", fname)
endfunction

" format the statusline
set statusline=
set statusline+=%{StatusLineBuffNum()}
set statusline+=\%{StatusLineFileName()}
set statusline+=%m

" right section
set statusline+=%=
" file format
set statusline+=%{StatusLineFormat()}
" file type
set statusline+=\ %{StatusLineFiletype()}
" line number
set statusline+=\ %l,
" column number
set statusline+=%2c
 "% of file
set statusline+=\ %p%%

" end statusline

" }}}

" general language settings {{{

augroup lang
  autocmd!

  autocmd FileType html setlocal shiftwidth=2 tabstop=2 softtabstop=2
  autocmd FileType go setlocal shiftwidth=8 tabstop=8 softtabstop=8
  autocmd FileType c setlocal shiftwidth=8 tabstop=8 softtabstop=8
  autocmd FileType python setlocal shiftwidth=4 tabstop=4 softtabstop=4
  autocmd FileType scala setlocal shiftwidth=2 tabstop=2 softtabstop=2
  autocmd FileType vim setlocal shiftwidth=2 tabstop=2 softtabstop=2
  autocmd FileType ruby setlocal shiftwidth=2 tabstop=2 softtabstop=2
  autocmd FileType eruby setlocal shiftwidth=2 tabstop=2 softtabstop=2
  "autocmd BufRead,BufNewFile *.md setlocal textwidth=80
  "autocmd BufRead,BufNewFile *.html setlocal textwidth=80
augroup END

" python {{{
" autopep8 on gq
autocmd FileType python setlocal formatprg=autopep8\ -

" turn on python autocomplete
autocmd FileType python set omnifunc=pythoncomplete#Complete

" auto close pydoc window
autocmd CursorMovedI * if pumvisible() == 0|pclose|endif
autocmd InsertLeave * if pumvisible() == 0|pclose|endif
" }}}

" {{{ HTML
iabbrev </ </<C-X><C-O>
imap <C-Space> <C-X><C-O>
" }}}

" }}}

" custom stuff {{{

" remap :W to write file
cmap W w

" remap :Q to quit
cmap Q q

" remap tag pop stack
nnoremap <c-[> <C-T>

" highlight current line in active window only
"augroup BgHighlight
"    autocmd!
"    autocmd WinEnter * set cul
"    autocmd WinLeave * set nocul
"augroup END

" show list of digraphs -- special symbols
nnoremap <localleader>D :help digraphs<cr>:175<cr>

" upper case last word using ctrl+u
inoremap <C-u> <esc>mzgUiw`za

" Shift-Tab enters actual tab
inoremap <S-Tab> <C-V><Tab>

" stay where you are on * from fatih (http://www.github.com/fatih/dotfiles)
nnoremap <silent> * :let stay_star_view = winsaveview()<cr>*:call winrestview(stay_star_view)<cr>

" move line of text up, down using Alt-j/k
nnoremap <M-j> mz:m+<cr>`z
nnoremap <M-k> mz:m-2<cr>`z
vnoremap <M-j> :m'>+<cr>`<my`>mzgv`yo`z
vnoremap <M-k> :m'<-2<cr>`>my`<mzgv`yo`z

" switch between files with \\
nnoremap <localleader><localleader> <c-^>

" remap % to tab (to find matching bracket pairs)
nnoremap <tab> %
vnoremap <tab> %

" toggle line numbers
nnoremap <silent> <Leader>n :set invnumber<CR>

" show avilable marks and be ready to swtich
nnoremap <leader>mm :<C-u>marks<CR>:normal! `

" show buffers and be ready to switch
nnoremap <silent> <leader>bb :<C-u>:buffers<CR>:buffer<space>

" Disable highlight when <leader><cr> is pressed
nnoremap <silent> <leader><cr> :nohlsearch<cr>

" higlight whitespace, but do not highlight in insert mode
highlight ExtraWhitespace ctermbg=red guibg=red
match ExtraWhitespace /\s\+$/
augroup hiwhitespace
  autocmd!
  autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
  autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
  autocmd InsertLeave * match ExtraWhitespace /\s\+$/
  autocmd BufWinLeave * call clearmatches()
augroup END

" Clean trailing whitespace
nnoremap <silent> <leader>W mz:%s/\s\+$//<cr>:let @/=''<cr>`z

" Switch CWD to the directory of the open buffer
nnoremap <leader>cd :cd %:p:h<cr>:pwd<cr>

" Automatically cd into the directory that the file is in
"autocmd BufEnter * execute "chdir ".escape(expand("%:p:h"), ' ')
"set autochdir

" resize splits when window is resized
augroup resize
  autocmd!
  autocmd VimResized * :wincmd =
augroup END

" netrw
nnoremap <Leader>o :Vexplore<cr>

let g:netrw_banner=0
let g:netrw_browse_split=4
let g:netrw_altv=1
let g:netrw_liststyle=3
let g:netrw_list_hide=netrw_gitignore#Hide()
let g:netrw_winsize = 25

" }}}

" {{{ functions

" quick way to open quickfix window
if !exists('*OpenQuickfix')
  func OpenQuickfix()
    :copen
  endf
  command C call OpenQuickfix()
endif

" use ctrl-s to vimgrep and open results in quickfix window
function! FindAll()
  call inputsave()
  let p = input('Enter pattern:')
  call inputrestore()
  execute 'vimgrep "'.p.'" % |copen'
endfunction
nnoremap <C-s> :call FindAll()<cr>

" call gitgrep with :G
if !exists('*GitGrep')
  func GitGrep(...)
    let save = &grepprg
    set grepprg=git\ grep\ -n\ $*
    let s = 'grep'
    for i in a:000
      let s = s . ' ' . i
    endfor
    exe s
    let &grepprg = save
  endfun
  command -nargs=? G call GitGrep(<f-args>)
endif

" git grep for word under cursor
if !exists('*GitGrepWord')
  func GitGrepWord()
    normal! "zyiw
    call GitGrep('-w -e ', getreg('z'))
  endf
endif
nnoremap <C-x>G :call GitGrepWord()<CR>

" generate tags quickly
if !exists('*GenerateTags')
  func GenerateTags()
    :! ctags -R
  endf
  command T call GenerateTags()
endif


"}}}

" moving around, tabs, windows and buffers {{{

" Smart way to move between windows
nnoremap <C-j> <C-W>j
nnoremap <C-k> <C-W>k
nnoremap <C-h> <C-W>h
nnoremap <C-l> <C-W>l
nnoremap <leader>ww <C-w>w
nnoremap <A-o> <C-w>w
nmap <leader>w <C-W>

" tab and buffer management
nnoremap <leader>bp :bprevious<cr>
nnoremap <leader>bn :bnext<cr>
nnoremap <leader>bd :bdelete<cr>
nnoremap <leader>tp :tabprevious<cr>
nnoremap <leader>tn :tabnext<cr>
nnoremap <leader>tt :tabnext<cr>

" resize splits
nnoremap <M-[> <C-w><
nnoremap <M-=> <C-w>+
nnoremap <M--> <C-w>-
nnoremap <M-]> <C-w>>

" Useful mappings for managing tabs
nnoremap <leader>tN :tabnew<cr>
nnoremap <leader>to :tabonly<cr>
nnoremap <leader>tc :tabclose<cr>
nnoremap <leader>th :-tabmove<cr>
nnoremap <leader>tl :+tabmove<cr>

"}}}

" highlight interesting words {{{

augroup highlight_interesting_word
  autocmd!
  " This mini-plugin provides a few mappings for highlighting words temporarily.
  "
  " Sometimes you're looking at a hairy piece of code and would like a certain
  " word or two to stand out temporarily.  You can search for it, but that only
  " gives you one color of highlighting.  Now you can use <leader>N where N is
  " a number from 1-6 to highlight the current word in a specific color.

  " credit: https://github.com/paulirish/dotfiles/blob/master/.vimrc

  function! HiInterestingWord(n) " {{{
    " Save our location.
    normal! mz

    " Yank the current word into the z register.
    normal! "zyiw

    " Calculate an arbitrary match ID.  Hopefully nothing else is using it.
    let mid = 86750 + a:n

    " Clear existing matches, but don't worry if they don't exist.
    silent! call matchdelete(mid)

    " Construct a literal pattern that has to match at boundaries.
    let pat = '\V\<' . escape(@z, '\') . '\>'

    " Actually match the words.
    call matchadd("InterestingWord" . a:n, pat, 1, mid)

    " Move back to our original location.
    normal! `z
  endfunction " }}}

  " Mappings {{{
  nnoremap <silent> <leader>1 :call HiInterestingWord(1)<cr>
  nnoremap <silent> <leader>2 :call HiInterestingWord(2)<cr>
  nnoremap <silent> <leader>3 :call HiInterestingWord(3)<cr>
  nnoremap <silent> <leader>4 :call HiInterestingWord(4)<cr>
  nnoremap <silent> <leader>5 :call HiInterestingWord(5)<cr>
  nnoremap <silent> <leader>6 :call HiInterestingWord(6)<cr>
  " }}}

  " Default Highlights {{{
  hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#ffa724 ctermbg=214
  hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
  hi def InterestingWord3 guifg=#000000 ctermfg=16 guibg=#8cffba ctermbg=121
  hi def InterestingWord4 guifg=#000000 ctermfg=16 guibg=#b88853 ctermbg=137
  hi def InterestingWord5 guifg=#000000 ctermfg=16 guibg=#ff9eb8 ctermbg=211
  hi def InterestingWord6 guifg=#000000 ctermfg=16 guibg=#ff2c4b ctermbg=195
  " }}}
augroup END
" }}}

" verbose debugging {{{

function! ToggleVerbose()
    if !&verbose
        set verbosefile=~/.vim/log/verbose.log
        set verbose=15
    else
        set verbose=0
        set verbosefile=
    endif
endfunction

" }}}

" notes {{{

" :helpgrep <text> - grep for <text> in all help docs
" :cn :cp to go to next or previous result from :helpgrep
" Tags:
" - Use ^] to jump to tag under cursor
" - Use g^] for ambiguous tags
" - Use ^t to jump back up the tag stack

"}}}
